"""
Interview Script Executor for AISET Process Engine

This module loads and executes interview scripts from JSON files.
It is part of the "Codification of the Systems Engineer" - providing
deterministic, verifiable interview flows.

Key Features:
- Load scripts and questions from JSON files
- Conditional question flow based on context
- Question variant selection
- Integration with Data Capture Service

Traceability: REQ-IS-001 to REQ-IS-008
"""

import json
import random
from pathlib import Path
from datetime import datetime
from typing import Dict, List, Optional, Any
from dataclasses import dataclass, field

from .data_capture import DataCaptureService, CaptureResult, validate_answer


# =============================================================================
# DATA CLASSES
# =============================================================================

@dataclass
class Question:
    """A question to present to the user"""
    question_id: str
    text: str
    help_text: Optional[str] = None
    data_type: str = "text"  # text, textarea, selection, multiselect
    options: List[Dict] = field(default_factory=list)
    required: bool = True
    validation_rules: List[Dict] = field(default_factory=list)


@dataclass
class AnswerResult:
    """Result of processing an answer"""
    valid: bool
    error: Optional[str] = None
    next_question_id: Optional[str] = None
    context_updates: Dict[str, Any] = field(default_factory=dict)
    auto_sets: List[Dict] = field(default_factory=list)
    capture_result: Optional[CaptureResult] = None
    phase_complete: bool = False


@dataclass
class InterviewState:
    """Current state of an interview"""
    script_id: str
    current_sub_phase: str
    current_question_id: str
    questions_answered: List[str] = field(default_factory=list)
    questions_skipped: List[str] = field(default_factory=list)
    context: Dict[str, Any] = field(default_factory=dict)
    started_at: datetime = field(default_factory=datetime.utcnow)
    last_interaction: datetime = field(default_factory=datetime.utcnow)


# =============================================================================
# INTERVIEW SCRIPT EXECUTOR
# =============================================================================

class InterviewScriptExecutor:
    """
    Loads and executes interview scripts.

    This is a deterministic executor - questions and flow are defined
    in JSON, not generated by AI.
    """

    SCRIPTS_PATH = Path(__file__).parent.parent / "interview_scripts"

    def __init__(self, script_name: str, db_session=None):
        """
        Initialize the executor for a specific script.

        Args:
            script_name: Name of the script directory (e.g., "project_initialization")
            db_session: Optional database session for data capture
        """
        self.script_name = script_name
        self.db_session = db_session
        self.script = self._load_script()
        self.questions = self._load_questions()
        self.data_capture = DataCaptureService(db_session)

    def _load_script(self) -> Dict:
        """Load the main script definition."""
        script_path = self.SCRIPTS_PATH / self.script_name / "script.json"

        if not script_path.exists():
            raise FileNotFoundError(f"Script not found: {script_path}")

        with open(script_path, 'r') as f:
            return json.load(f)

    def _load_questions(self) -> Dict[str, Dict]:
        """Load all question definitions."""
        questions = {}
        questions_dir = self.SCRIPTS_PATH / self.script_name / "questions"

        if not questions_dir.exists():
            return questions

        for question_file in questions_dir.glob("*.json"):
            try:
                with open(question_file, 'r') as f:
                    question_def = json.load(f)
                    question_id = question_def.get("question_id")
                    if question_id:
                        questions[question_id] = question_def
            except json.JSONDecodeError:
                continue

        return questions

    # =========================================================================
    # QUESTION RETRIEVAL
    # =========================================================================

    def get_first_question(self, context: Dict = None) -> Question:
        """
        Get the first question to start the interview.

        Args:
            context: Initial context (optional)

        Returns:
            The first Question to present
        """
        context = context or {}

        # Get first sub-phase
        sub_phases = self.script.get("sub_phases", [])
        if not sub_phases:
            raise ValueError("Script has no sub-phases defined")

        first_sub_phase = sub_phases[0]
        first_question_ids = first_sub_phase.get("questions", [])

        if not first_question_ids:
            raise ValueError("First sub-phase has no questions")

        # Get first question, checking skip conditions
        for question_id in first_question_ids:
            if not self._should_skip(question_id, context):
                return self.get_question(question_id, context)

        raise ValueError("All questions in first sub-phase should be skipped")

    def get_question(self, question_id: str, context: Dict = None) -> Question:
        """
        Get a question by ID.

        Args:
            question_id: The question ID
            context: Current interview context

        Returns:
            Question object ready to present
        """
        context = context or {}

        if question_id not in self.questions:
            raise ValueError(f"Question '{question_id}' not found")

        question_def = self.questions[question_id]

        # Check if should skip
        if self._should_skip(question_id, context):
            # Find next question
            next_id = self._get_next_question_id(question_id, context)
            if next_id:
                return self.get_question(next_id, context)
            raise ValueError(f"Question '{question_id}' should be skipped but no next question")

        # Select variant
        variant_text = self._select_variant(question_def)

        # Filter options by context
        options = self._filter_options(question_def.get("options", []), context)

        return Question(
            question_id=question_id,
            text=variant_text,
            help_text=question_def.get("help_text"),
            data_type=question_def.get("data_type", "text"),
            options=options,
            required=question_def.get("required", True),
            validation_rules=question_def.get("validation", {}).get("rules", [])
        )

    def _select_variant(self, question_def: Dict) -> str:
        """
        Select a question variant.

        For now, uses random selection. Could be made context-aware.
        """
        variants = question_def.get("variants", [])
        if variants:
            return random.choice(variants)
        return question_def.get("text", "")

    def _filter_options(self, options: List[Dict], context: Dict) -> List[Dict]:
        """
        Filter options based on context conditions.

        Args:
            options: List of option definitions
            context: Current context

        Returns:
            Filtered list of options
        """
        filtered = []

        for option in options:
            condition = option.get("condition")
            if condition:
                if not self._evaluate_condition(condition, context):
                    continue

            # Return option without the condition field
            filtered_option = {k: v for k, v in option.items() if k != "condition"}
            filtered.append(filtered_option)

        return filtered

    def _should_skip(self, question_id: str, context: Dict) -> bool:
        """
        Check if a question should be skipped based on context.

        Args:
            question_id: Question ID to check
            context: Current context

        Returns:
            True if question should be skipped
        """
        if question_id not in self.questions:
            return True

        question_def = self.questions[question_id]
        skip_conditions = question_def.get("skip_if", [])

        for condition in skip_conditions:
            if self._evaluate_condition(condition, context):
                return True

        return False

    def _evaluate_condition(self, condition: Dict, context: Dict) -> bool:
        """
        Evaluate a condition against the current context.

        Args:
            condition: Condition definition (e.g., {"context.industry": ["aerospace"]})
            context: Current context

        Returns:
            True if condition is met
        """
        for key, expected_values in condition.items():
            # Handle nested keys like "context.industry"
            if key.startswith("context."):
                actual_key = key[8:]  # Remove "context." prefix
                actual_value = context.get(actual_key)
            else:
                actual_value = context.get(key)

            # Check if actual value matches any expected value
            if isinstance(expected_values, list):
                if actual_value not in expected_values:
                    return False
            else:
                if actual_value != expected_values:
                    return False

        return True

    # =========================================================================
    # ANSWER PROCESSING
    # =========================================================================

    def process_answer(
        self,
        question_id: str,
        answer: Any,
        context: Dict,
        project_id: int = None
    ) -> AnswerResult:
        """
        Process a user's answer.

        Args:
            question_id: ID of the question being answered
            answer: The user's answer
            context: Current interview context
            project_id: Project ID for data storage

        Returns:
            AnswerResult with next steps
        """
        if question_id not in self.questions:
            return AnswerResult(
                valid=False,
                error=f"Question '{question_id}' not found"
            )

        question_def = self.questions[question_id]

        # 1. Validate
        validation_errors = validate_answer(answer, question_def)
        if validation_errors:
            error_messages = [e.error for e in validation_errors if e.error]
            return AnswerResult(
                valid=False,
                error="; ".join(error_messages) if error_messages else "Validation failed"
            )

        # 2. Capture data (validate, transform, store)
        capture_result = None
        if project_id:
            capture_result = self.data_capture.capture(
                value=answer,
                question_def=question_def,
                project_id=project_id,
                context=context
            )

        # 3. Determine next action from on_answer
        on_answer = question_def.get("on_answer", {})

        # Try to match specific answer value, fall back to "default"
        answer_key = str(answer) if not isinstance(answer, list) else "default"
        answer_action = on_answer.get(answer_key) or on_answer.get("default", {})

        # 4. Build context updates
        context_updates = answer_action.get("set_context", {})

        # Replace $value placeholder
        for key, val in list(context_updates.items()):
            if val == "$value":
                context_updates[key] = answer

        # Add any updates from capture
        if capture_result and capture_result.context_updates:
            context_updates.update(capture_result.context_updates)

        # 5. Get next question ID
        next_question_id = answer_action.get("next_question")

        # Check if interview is complete
        phase_complete = next_question_id is None

        # 6. Get auto-set values
        auto_sets = answer_action.get("auto_set", [])

        return AnswerResult(
            valid=True,
            next_question_id=next_question_id,
            context_updates=context_updates,
            auto_sets=auto_sets,
            capture_result=capture_result,
            phase_complete=phase_complete
        )

    def _get_next_question_id(
        self,
        current_question_id: str,
        context: Dict
    ) -> Optional[str]:
        """
        Get the next question ID based on script order.

        Args:
            current_question_id: Current question ID
            context: Current context

        Returns:
            Next question ID or None if complete
        """
        # Find current question's sub-phase
        for sub_phase in self.script.get("sub_phases", []):
            questions = sub_phase.get("questions", [])

            if current_question_id in questions:
                # Find position in list
                idx = questions.index(current_question_id)

                # Try next question in same sub-phase
                for next_idx in range(idx + 1, len(questions)):
                    next_id = questions[next_idx]
                    if not self._should_skip(next_id, context):
                        return next_id

                # Try next sub-phase
                return self._get_first_question_of_next_subphase(sub_phase, context)

        return None

    def _get_first_question_of_next_subphase(
        self,
        current_sub_phase: Dict,
        context: Dict
    ) -> Optional[str]:
        """Get first question of the next sub-phase."""
        sub_phases = self.script.get("sub_phases", [])
        current_order = current_sub_phase.get("order", 0)

        for sub_phase in sub_phases:
            if sub_phase.get("order", 0) > current_order:
                questions = sub_phase.get("questions", [])
                for question_id in questions:
                    if not self._should_skip(question_id, context):
                        return question_id

        return None

    # =========================================================================
    # STATE MANAGEMENT
    # =========================================================================

    def create_initial_state(self) -> InterviewState:
        """Create initial state for a new interview."""
        sub_phases = self.script.get("sub_phases", [])
        first_sub_phase = sub_phases[0] if sub_phases else {}
        first_questions = first_sub_phase.get("questions", [])
        first_question_id = first_questions[0] if first_questions else ""

        return InterviewState(
            script_id=self.script.get("script_id", ""),
            current_sub_phase=first_sub_phase.get("sub_phase_id", ""),
            current_question_id=first_question_id,
            context={}
        )

    def update_state(
        self,
        state: InterviewState,
        question_id: str,
        answer_result: AnswerResult
    ) -> InterviewState:
        """
        Update interview state after an answer.

        Args:
            state: Current state
            question_id: Answered question ID
            answer_result: Result from process_answer

        Returns:
            Updated state
        """
        # Mark question as answered
        if question_id not in state.questions_answered:
            state.questions_answered.append(question_id)

        # Update context
        state.context.update(answer_result.context_updates)

        # Update current question
        if answer_result.next_question_id:
            state.current_question_id = answer_result.next_question_id

            # Update sub-phase if needed
            if answer_result.next_question_id in self.questions:
                next_q = self.questions[answer_result.next_question_id]
                state.current_sub_phase = next_q.get("sub_phase", state.current_sub_phase)

        # Update timestamp
        state.last_interaction = datetime.utcnow()

        return state

    # =========================================================================
    # PROGRESS TRACKING
    # =========================================================================

    def get_progress(self, state: InterviewState) -> Dict:
        """
        Get interview progress information.

        Args:
            state: Current interview state

        Returns:
            Progress dictionary
        """
        total_questions = len(self.questions)
        answered = len(state.questions_answered)
        skipped = len(state.questions_skipped)

        sub_phases = self.script.get("sub_phases", [])
        current_sub_phase_idx = 0

        for idx, sp in enumerate(sub_phases):
            if sp.get("sub_phase_id") == state.current_sub_phase:
                current_sub_phase_idx = idx
                break

        return {
            "script_id": state.script_id,
            "total_questions": total_questions,
            "questions_answered": answered,
            "questions_skipped": skipped,
            "progress_percent": (answered / total_questions * 100) if total_questions > 0 else 0,
            "current_sub_phase": state.current_sub_phase,
            "current_sub_phase_index": current_sub_phase_idx,
            "total_sub_phases": len(sub_phases),
            "current_question_id": state.current_question_id
        }


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================

def list_available_scripts() -> List[Dict]:
    """List all available interview scripts."""
    scripts = []
    scripts_path = InterviewScriptExecutor.SCRIPTS_PATH

    if not scripts_path.exists():
        return scripts

    for script_dir in scripts_path.iterdir():
        if script_dir.is_dir():
            script_file = script_dir / "script.json"
            if script_file.exists():
                try:
                    with open(script_file, 'r') as f:
                        script_def = json.load(f)
                        scripts.append({
                            "script_id": script_def.get("script_id"),
                            "name": script_def.get("name"),
                            "description": script_def.get("description"),
                            "phase": script_def.get("phase"),
                            "sub_phase_count": len(script_def.get("sub_phases", []))
                        })
                except json.JSONDecodeError:
                    continue

    return scripts


def create_interview(script_name: str, db_session=None) -> InterviewScriptExecutor:
    """
    Convenience function to create an interview executor.

    Args:
        script_name: Name of the script directory
        db_session: Optional database session

    Returns:
        InterviewScriptExecutor instance
    """
    return InterviewScriptExecutor(script_name, db_session)
